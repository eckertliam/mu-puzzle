#lang racket

(require rackunit)

(define string-to-list
  (lambda (str)
    (map string (string->list str))))

(check-equal? (string-to-list "me") '("m" "e"))

(define list-to-string
  (lambda (l)
    (string-join l "")))

(check-equal? (list-to-string '("m" "e")) "me")

(define last-element
  (lambda (l)
    (cond
      ((null? (cdr l)) (car l))
      (else (last-element (cdr l))))))

(check-equal? (last-element '(1 2 3 4)) '4)

(define can-add-u?
  (lambda (l)
    (cond
      ((eq? (last-element l) "i") #t)
      (else #f))))

(check-equal? (can-add-u? '("m" "i")) '#t)
(check-equal? (can-add-u? '("m" "u")) '#f)

(define remove-last
  (lambda (l)
    (cond
      ((null? l)(error 'l "is an empty list"))
      ((null? (cdr l)) '())
      (else (cons (car l) (remove-last (cdr l)))))))

(check-equal? (remove-last '(1 2 3)) '(1 2))

(define add-u
  (lambda (l)
    (cond
      ((null? l)
       (error 'l "is an empty list"))
      ((can-add-u? l)
       (let ([rl (remove-last l)])
         (append rl (list "u"))))
      (else (error 'l "is unkwown")))))

(check-equal? (add-u '("m" "i" "i")) '("m" "i" "u"))

;; every proof must begin with "m"
(define starts-with-m?
  (lambda (l)
    (cond
      ((eq? (car l) "m") #t)
      (else #f))))

(define double-string
  (lambda (l)
    (cond
      ((null? (cdr l)) (error 'l "cannot double a string which does not exist"))
      (else (append l (cdr l))))))

(check-equal? (double-string '("m" "u")) '("m" "u" "u"))

(define test '(1 2 3 4 5 6 7 8 9 10))

(define slice
  (lambda (l offset n)
    (take (drop l offset) n)))

(check-equal? (slice '(1 2 3 4 5 6 7 8 9 10) 2 2) '(3 4))

(define find-sub-list
  (lambda (l sub-l)
    (let ([rl '()])
      (for ([offset (range 0 (- (length l) (length sub-l)))])
        (write (slice l offset (length sub-l)))
        (cond
          ((eq? (slice l offset (length sub-l)) sub-l) (set! rl (append rl (list offset))))))
      rl)))

(check-equal? (find-sub-list '(1 2 3 4 5 6 7 8 9 10) '(2 3 4)) ('1))

